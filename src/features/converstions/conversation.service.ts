import {
  ConversationRepository,
  ConversationWithDetails,
} from "./conversation.repository";
import { Conversation } from "./conversation.model";
import { io } from "../../server";
import { MessageEvent } from "../messages/message.model";

export class ConversationService {
  private readonly repository: ConversationRepository;

  constructor() {
    this.repository = new ConversationRepository();
  }

  /**
   * Cr√©e une conversation ou retourne l'existante (√©vite les doublons)
   * Bas√© sur applicationId pour s√©parer les conversations par mission
   */
  async createOrGetConversation(
    data: Partial<Conversation>,
    currentUserId?: string,
  ): Promise<ConversationWithDetails> {
    let conversation: ConversationWithDetails | null = null;

    // Si applicationId est fourni, chercher par applicationId
    if (data.applicationId) {
      conversation = await this.repository.findConversationByApplication(
        data.applicationId,
        currentUserId,
      );
    } else {
      // Sinon, utiliser l'ancienne m√©thode (pour compatibilit√©)
      conversation = await this.repository.findConversation(
        data.freelanceId!,
        data.companyId!,
        currentUserId,
      );
    }

    if (!conversation) {
      const created = await this.repository.createConversation(data);
      // R√©cup√©rer la conversation cr√©√©e avec d√©tails
      if (created.applicationId) {
        conversation = await this.repository.findConversationByApplication(
          created.applicationId,
          currentUserId,
        );
      } else {
        conversation = await this.repository.findConversation(
          created.freelanceId,
          created.companyId,
          currentUserId,
        );
      }
    }
    return conversation!;
  }

  /**
   * Trouve une conversation par applicationId
   */
  async findConversationByApplication(
    applicationId: string,
    currentUserId?: string,
  ): Promise<ConversationWithDetails | null> {
    return this.repository.findConversationByApplication(
      applicationId,
      currentUserId,
    );
  }

  /**
   * R√©cup√®re une conversation par son ID
   */
  async getConversationById(id: string): Promise<Conversation | null> {
    return this.repository.getConversationById(id);
  }

  /**
   * Trouve une conversation existante entre un freelance et une entreprise (avec d√©tails)
   */
  async findConversation(
    freelanceId: string,
    companyId: string,
    currentUserId?: string,
  ): Promise<ConversationWithDetails | null> {
    return this.repository.findConversation(
      freelanceId,
      companyId,
      currentUserId,
    );
  }

  /**
   * R√©cup√®re toutes les conversations d'un utilisateur (avec d√©tails, pagination support√©e)
   * @param userId - ID de l'utilisateur
   * @param limit - Nombre d'√©l√©ments par page (d√©faut : 20)
   * @param offset - D√©calage (d√©faut : 0)
   */
  async getConversationsForUser(
    userId: string,
    limit: number = 20,
    offset: number = 0,
  ): Promise<ConversationWithDetails[]> {
    return this.repository.getConversationsForUser(userId, limit, offset);
  }

  /**
   * Met √† jour le compteur de messages non lus pour une conversation
   */
  async updateUnreadCount(
    conversationId: string,
    userId: string,
  ): Promise<number> {
    return this.repository.updateUnreadCount(conversationId, userId);
  }

  /**
   * R√©cup√®re les compteurs de messages non lus pour toutes les conversations d'un utilisateur
   */
  async getUnreadCountsForUser(userId: string): Promise<Map<string, number>> {
    return this.repository.getUnreadCountsForUser(userId);
  }

  /**
   * Marque tous les messages non lus d'une conversation comme lus
   * √âmet les √©v√©nements socket appropri√©s pour synchroniser les clients
   */
  async markAllMessagesAsReadInConversation(
    conversationId: string,
    userId: string,
  ): Promise<number> {
    try {
      console.log(
        `üéØ [ConversationService] markAllMessagesAsReadInConversation called for conversation: ${conversationId}, user: ${userId}`,
      );

      // 1. R√©cup√©rer les messages avant de les marquer (pour les IDs et exp√©diteurs)
      const { db } = await import("../../config/database");
      const messagesQuery = `
        SELECT id, sender_id, receiver_id
        FROM messages
        WHERE conversation_id = $1
        AND receiver_id = $2
        AND is_read = false
        AND deleted_at IS NULL
      `;
      const messagesResult = await db.query(messagesQuery, [
        conversationId,
        userId,
      ]);
      const unreadMessages = messagesResult.rows;

      console.log(
        `üìã Found ${unreadMessages.length} unread messages to mark`,
        unreadMessages.map((m) => ({ id: m.id, sender: m.sender_id })),
      );

      if (unreadMessages.length === 0) {
        console.log(
          `‚ÑπÔ∏è No unread messages found in conversation ${conversationId} for user ${userId}`,
        );
        return 0;
      }

      // 2. Marquer les messages comme lus en base
      const markedCount =
        await this.repository.markAllMessagesAsReadInConversation(
          conversationId,
          userId,
        );

      console.log(
        `‚úÖ ${markedCount} messages marked as read in database for conversation ${conversationId}`,
      );

      if (markedCount > 0) {
        // 3. Calculer le nouveau compteur de non-lus
        const newUnreadCount = await this.repository.updateUnreadCount(
          conversationId,
          userId,
        );

        console.log(
          `üìä New unread count for conversation ${conversationId}: ${newUnreadCount}`,
        );

        // 4. Pr√©parer les donn√©es pour les √©v√©nements
        const messageIds = unreadMessages.map((msg) => msg.id);
        const uniqueSenderIds = new Set(
          unreadMessages.map((msg) => msg.sender_id),
        );

        console.log(
          `üì§ Preparing to notify - Message IDs: [${messageIds.join(", ")}]`,
        );
        console.log(
          `üë• Unique sender IDs: [${Array.from(uniqueSenderIds).join(", ")}]`,
        );

        // 5. Notifier le destinataire (celui qui a marqu√© comme lu)
        io.to(userId).emit("batch_messages_marked_read", {
          messageIds,
          conversationId,
          newUnreadCount,
          markedCount,
          timestamp: new Date().toISOString(),
        });

        console.log(
          `üì¨ Emitted 'batch_messages_marked_read' to receiver ${userId} - new count: ${newUnreadCount}`,
        );

        // 6. Notifier tous les exp√©diteurs uniques
        uniqueSenderIds.forEach((senderId) => {
          if (senderId !== userId) {
            // √âviter de notifier l'utilisateur qui marque
            const senderMessageIds = messageIds.filter((id) => {
              const msg = unreadMessages.find((m) => m.id === id);
              return msg && msg.sender_id === senderId;
            });

            io.to(senderId).emit("batch_messages_read", {
              messageIds: senderMessageIds,
              userId,
              conversationId,
              markedCount: senderMessageIds.length,
              timestamp: new Date().toISOString(),
            });

            console.log(
              `üì¨ Emitted 'batch_messages_read' to sender ${senderId} - ${senderMessageIds.length} messages [${senderMessageIds.join(", ")}]`,
            );
          } else {
            console.log(
              `‚è≠Ô∏è Skipping notification to ${senderId} (same as receiver)`,
            );
          }
        });

        console.log(
          `‚úÖ [ConversationService] Successfully processed ${markedCount} messages for conversation ${conversationId}`,
        );
      }

      return markedCount;
    } catch (error) {
      console.error(
        `‚ùå [ConversationService] Error in markAllMessagesAsReadInConversation:`,
        error,
      );
      throw error;
    }
  }
}
